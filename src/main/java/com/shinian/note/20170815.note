在Fibonacci里面使用的都是int类型,但是类型参数里却是Integer,这个例子引出了泛型的局限性,基本类型无法作为类型参数

泛型方法
    是否包含泛型方法 和这个类是不是泛型类,没有关系
    泛型方法是的该方法能够独立与类而产生变化,一下是一个基本的知道原则,无论何时,只要你能做到,你就应该使用泛型方法,
    也就是说,如果使用泛型方法可以取代将整个类反省花,那么就应该只是用泛型方法,
    另外,对一个类的static方法而言,无法访问泛型类的类型参数,所以,如果static方法需要使用泛型能力.就必须使其成为泛型方法
    要定义泛型方法,只需将泛型参数列表置于返回值之前
    public <T> void f(T t){}

注意:当使用泛型类时,必须在创建对象的时候指定类型参数的值,而使用泛型方法的时候,通常不指明参数类型,因为编译器会为我们找出具体的类型
而是用泛型方法的时候,不用指定类型,因为编译器会为我们找出具体的类型,这称为(类型参数推断)因为我们可以像调用普通方法一样调用f()
看起来就想被重载了无限次一样,如果调用时传入基本类型,那么就会自动打包
