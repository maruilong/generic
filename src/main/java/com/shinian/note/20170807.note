一般的类和方法,只能使用具体的类型.要么是基本类型,要么是自定义的类,如果要编写可以应用于多种类型的代码,这种刻板的限制对代码的束缚就会很大

面向对象中,多态算是一种泛化机制,例如,你可以将方法的参数类型设为基类,那么该方法就可以接受从这个基类中导出的任何类作为参数,
这样的方法更加通用一些,可应用的地方也多一些,再类的内部也是如此凡是需要说明类型的地方,如果都是用基类
确实能狗具备更好的灵活性,但是考虑到除了final类不能扩展,其他任何类都可以被扩展,所以这种类火星大多数时候也会有一些性能损耗
    有时候,单独拘泥于单继承体系,也会使程序首先太多,如果方法的参数是一个接口,而不是一个类,这样限制就少了很多,
因为任何实现了该接口的的类都能狗满足该方法,这也包括暂时还不存在的类,这就给与客户端程序员一种选择,他们可以通过实现一个接口
来实现类或者方法,接口允许我们快捷的实现类继承.
    有的时候,即使使用接口,对程序的约束也还是太强了,因为一但指明了接口,他就要求你的代码必须使用特定的接口,而我们希望打到的目的是编写更
通用的代码,要使代码能够应用于"某种不确定的类型",而不是一个接口或者类
    这就是javaSE5的重大变化之一:泛型的概念,泛型实现了参数化类型的概念,使代码可以应用于多种类型,"泛型这个术语的意思是":"适用于许多许多的类型",
泛型在编程语言中出现过解耦类的方法与所使用的类型之间的约束,
    泛型是一个很有益的补充,那么,在学习了java中的泛型之后,在你创建参数化类型的一个实例时,编译器会为你负责转型操作,并且保证类型的正确性;
许多原因促成了泛型的出现,而最引人注目的一个原因,就是为了创造容器类
容器:就是存放要使用的对象的地方,数组也是如此,不过与简单的数组相比,容器类更加灵活,具备更多不同的功能,事实上,所有的容器在运行时都要求你持有一大堆对象

有些情况下,我们确实希望容器能够同时持有多种类型的对象,但是通常而言我们只用容器来储存一种类型的对象,泛型的主要目的就是用来指定容器要持有什么对象
而且由编译器来保证类型的正确性,因此,与其使用object,我们更喜欢暂时不指定类型,而是稍后在觉得使用什么类型,要达到这个目的,需要使用类型参数,用尖括号扩主,
放在类后面,然后在使用这个类的时候,在用实际的类型替换此类型参数

这就是java泛型的核心概念:告诉编译器想使用什么类型,然后编译器帮你处理一切细节




